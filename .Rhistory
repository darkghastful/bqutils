)
if (fn_match) {
# skip if already has roxygen above
if (i > 1L && grepl("^\\s*#'", lines[i-1L])) {
new_lines <- c(new_lines, line)
i <- i + 1L
next
}
# extract function name
fn_name <- sub(
"^\\s*([[:alnum:]._]+)\\s*(?:<-|=).*", "\\1", line
)
# extract argument names
arg_string <- sub(".*function\\s*\\(([^)]*)\\).*", "\\1", line)
args <- if (nzchar(arg_string)) strsplit(arg_string, ",")[[1L]] else character(0L)
args <- trimws(gsub("=.*$", "", args))
# build roxygen block
roxy <- c(
sprintf("#' %s", fn_name),
"#'",
"#' @description Brief description of what this function does",
"#'",
if (length(args) > 0L) sprintf("#' @param %s", args) else NULL,
"#' @return What this function returns",
"#' @export"
)
new_lines <- c(new_lines, roxy, line)
} else {
new_lines <- c(new_lines, line)
}
i <- i + 1L
}
writeLines(new_lines, con = file)
message("Processed ", basename(file))
}
}
insert_roxygen_skeleton("C:/Users/Bailey Quinn/iCloudDrive/Desktop/Github/R.packages/bqutils/R")
# 2) Read the raw lines so we can detect commented‐out or HTML‐commented functions
all_funs_path <- "C:/Users/Bailey Quinn/iCloudDrive/Desktop/Github/R.packages/functions/all.functions.R"
raw_lines     <- readLines(all_funs_path, warn = FALSE)
# 3) Parse with source references turned on
exprs <- parse(all_funs_path, keep.source = TRUE)
# 4) Split out each top‐level, non‐commented function, preserving exact formatting
out_dir <- "C:/Users/Bailey Quinn/iCloudDrive/Desktop/Github/R.packages/functions"
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
written <- 0L
for (e in exprs) {
if (
is.call(e) &&
identical(e[[1]], as.symbol("<-")) &&
is.symbol(e[[2]]) &&
is.call(e[[3]]) &&
identical(e[[3]][[1]], as.symbol("function"))
) {
fn_name <- as.character(e[[2]])
sr <- attr(e, "srcref")
if (!is.null(sr)) {
# slice out exact lines from source
start_line <- sr[[1]]
end_line   <- sr[[3]]
line_txt   <- raw_lines[start_line]
# skip if the definition line is R‐commented (#) or HTML‐commented (<!-- ... -->)
if (grepl("^\\s*#",    line_txt) ||
grepl("^\\s*<!--", line_txt)) {
next
}
fn_lines <- raw_lines[start_line:end_line]
} else {
# fallback: deparse the call (will lose original tabs, but ensures we write something)
fn_lines <- deparse(e)
}
writeLines(fn_lines,
con = file.path(out_dir, paste0(fn_name, ".R")))
written <- written + 1L
message("Wrote ", fn_name)
}
}
message("Done: wrote ", written, " function file(s) into ", out_dir)
#' find.break.limit
#'
#' @description Identifies break limits for max y value for use in ggplot
#'
#' @param value
#' @return breaklimits
#' @export
find.break.limit <- function(value) {
if (value <= 5e+05) {
test <- TRUE
a <- 1
while (test) {
if (value <= (5e+05/(a)) && value >= (2e+05/(a))) {
test <- FALSE
return((1e+05/(a)))
}
else if (value <= (2e+05/(a)) && value >= (1e+05/(a))) {
test <- FALSE
return((50000/(a)))
}
else if (value <= (1e+05/(a)) && value > (50000/(a))) {
test <- FALSE
return((25000/(a)))
}
a <- (a * 10)
}
return(a)
}
}
find.break.limit(80)
#' remove.na
#'
#' @description Removes all rows with NA values for an object (frame) or specified column in frame.
#'
#' @param object
#' @param column
#' @return object
#' @export
remove.na <- function(object, column = NA) {
if (class(object) == "data.frame") {
if (!is.na(column)) {
if (length(which(is.na(object[, column]) == FALSE)) !=
nrow(object)) {
object <- object[-c(which(is.na(object[, column]) ==
TRUE)), ]
}
}
else {
for (a in 1:length(ncol(object))) {
if (length(which(is.na(object[, a]) == FALSE)) !=
nrow(object)) {
object <- object[-c(which(is.na(object[, a]) ==
TRUE)), ]
}
}
}
}
else if (class(object) == "list" || class(object) == "character" ||
class(object) == "integer") {
if (length(which(is.na(object) == FALSE)) != length(object)) {
object <- object[-c(which(is.na(object) == TRUE))]
}
}
else if (class(object) == "phyloseq") {
object.frame <- sample.to.data.frame(object)
if (any(is.na(object.frame[, column]))) {
non.na <- row.names(object.frame[c(which(is.na(object.frame[,
column]) == FALSE)), ])
object <- prune_samples(non.na, object)
}
}
return(object)
}
remove.na(list(NA, 1, NA, 2, 3))
#' rename.column
#'
#' @description Renames specified column in frame.
#'
#' @param frame
#' @param colname.from
#' @param colname.to
#' @return frame
#' @export
rename.column <- function(frame, colname.from, colname.to) {
colnames(frame)[which.col.name(frame, colname.from)] <- colname.to
return(frame)
}
rename.column(test, "c", "d")
#' which.col.name
#'
#' @description (replace with which col row name)
#'
#' @param dataframe
#' @param col.name
#' @return What this function returns
#' @export
which.col.name <- function(dataframe, col.name) {
col.name.list <- c()
for (a in 1:length(col.name)) {
col.name.list[a] <- which(colnames(dataframe) == col.name[a])
}
return(col.name.list)
}
#' rename.column
#'
#' @description (relys on which.col.name) Renames specified column in frame.
#'
#' @param frame
#' @param colname.from
#' @param colname.to
#' @return frame
#' @export
rename.column <- function(frame, colname.from, colname.to) {
colnames(frame)[which.col.name(frame, colname.from)] <- colname.to
return(frame)
}
rename.column(test, "c", "d")
which.col.name(test, c("c", "a", "b"))
#' locate.element
#'
#' @description Identifies location of specified element within a column of the frame.
#'
#' @param frame
#' @param value
#' @param column
#' @return vector
#' @export
locate.element <- function(frame, value, column) {
return(which(frame[, column] == value))
}
locate.element(test, 1, "b") # which.rows changed to locate.element
replace.na(list(NA, 1, NA, 2, 3), 0)
#' replace.na
#'
#' @description Replaces all NA in object with specified value
#'
#' @param object
#' @param value
#' @return frame
#' @export
replace.na <- function(object, value) {
object[is.na(object)] <- value
return(object)
}
replace.na(list(NA, 1, NA, 2, 3), 0)
NaN
#' replace.nan
#'
#' @description Replaces all NaN in object with specified value
#'
#' @param object
#' @param value
#' @return object
#' @export
replace.nan <- function(object, value) {
object[is.nan(object)] <- value
return(object)
}
replace.nan(list(NaN, 1, NaN, 2, 3), 0)
#' replace.nan
#'
#' @description Replaces all NaN in object with specified value
#'
#' @param object
#' @param value
#' @return object
#' @export
replace.nan <- function(object, value) {
if (class(object) == "data.frame") {
for (a in 1:ncol(object)) {
object[, a][is.nan(object[, a])] <- value
}
}
else if (class(object) == "list" || class(object) == "character" ||
class(object) == "integer" || class(object) == "numeric") {
object[is.nan(object)] <- value
}
else {
for (a in 1:ncol(object)) {
object[, a][is.nan(object[, a])] <- value
}
}
return(object)
}
replace.nan(list(NaN, 1, NaN, 2, 3), 0)
#' replace.nan
#'
#' @description Replaces all NaN in object with specified value
#'
#' @param object
#' @param value
#' @return object
#' @export
replace.nan <- function(object, value) {
object[is.nan(object)] <- value
return(object)
}
replace.nan(c(NaN, 1, NaN, 2, 3), 0)
replace.specific(c(1, 2, 3), 1, 5)
#' replace.specific
#'
#' @description Locates all instances of a value and replaces them with the provided value.
#'
#' @param vector
#' @param value
#' @param replacement
#' @return vector
#' @export
replace.specific <- function(vector, value, replacement) {
vector[vector == value] <- replacement
return(vector)
}
replace.specific(c(1, 2, 3), 1, 5)
#' round.to
#'
#' @description Brief description of what this function does
#'
#' @param value
#' @param to
#' @param top.bottom
#' @return What this function returns
#' @export
round.to <- function(value, to, top.bottom = NA) {
if (is.na(top.bottom)) {
return(round(value/to) * to)
}
else if (top.bottom == "top") {
return(ceiling(value/to) * to)
}
else if (top.bottom == "bottom") {
return(floor(value/to) * to)
}
}
round.to(0.00356, 0.001)
round.to(0.00987, 0.001, "bottom")
find.break.limit(90)
frame <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
rownames(frame) <- LETTERS[1:9]
frame
frame <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
row.names.to.column(frame)
#'
#' @description Brief description of what this function does
#'
#' @param frame
#' @param numerical.rows
#' @return What this function returns
#' @export
#' @examples
#' frame <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
#' row
row.names.to.column <- function(frame, numerical.rows = FALSE) {
frame[, "row.name"] <- row.names(frame)
if (numerical.rows) {
row.names(frame) <- 1:nrow(frame)
}
return(frame)
}
row.names.to.column(frame)
frame <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
rownames(frame) <- LETTERS[1:9]
row.names.to.column(frame)
#' @examples
row.bind(list(frame, frame))
#' row.bind
#'
#' @description Binds multiple frames together by appending rows.
#'
#' @param frames
#' @return What this function returns
#' @export
#' @examples
#' frame <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
#'
row.bind <- function(frames) {
merged.frames <- frames[[1]]
for (a in 2:length(frames)) {
merged.frames <- rbind(merged.frames, frames[[a]])
}
return(merged.frames)
}
row.bind(list(frame, frame))
#'
#' @description Brief description of what this function does
#'
#' @param values
#' @param sigfigs
#' @param as.p
#' @return What this function returns
#' @export
#' @examples
#'
sigfill <- function(values, sigfigs = 2, as.p = FALSE) {
values <- uln(values)
out <- c()
if (!as.p) {
for (a in 1:length(values)) {
if (values[a] == 1) {
out[a] <- paste0("1.", paste0(rep(0, sigfigs),
collapse = ""))
}
else if ((values[a] < as.numeric(paste0("0.", paste0(rep(0,
(sigfigs - 1)), collapse = ""), "1")))) {
out[a] <- paste0("<0.", paste0(rep(0, (sigfigs -
1)), collapse = ""), "1")
}
else {
sig.dec <- (which(strsplit(as.character(values[a]),
"")[[1]] == ".") - 1) + sigfigs
out[a] <- formatC(round(values[a], digits = sigfigs),
digits = sig.dec, format = "fg", flag = "#")
out[a] <- strtrim(out[a], sig.dec + c(1, 2)[grepl("-",
out[a], fixed = TRUE) + 1])
}
}
}
else {
for (a in 1:length(values)) {
if (values[a] == 1) {
out[a] <- paste0("p=1.", paste0(rep(0, sigfigs),
collapse = ""))
}
else if ((values[a] < as.numeric(paste0("0.", paste0(rep(0,
(sigfigs - 1)), collapse = ""), "1")))) {
out[a] <- paste0("p<0.", paste0(rep(0, (sigfigs -
1)), collapse = ""), "1")
}
else {
sig.dec <- (which(strsplit(as.character(values[a]),
"")[[1]] == ".") - 1) + sigfigs
out[a] <- formatC(round(values[a], digits = sigfigs),
digits = sig.dec, format = "fg", flag = "#")
out[a] <- paste0("p=", strtrim(out[a], sig.dec +
c(1, 2)[grepl("-", out[a], fixed = TRUE) +
1]))
}
}
}
return(out)
}
sigfill(c(0.00123, 0.000987))
sigfill(c(0.00123, 0.000987), 4, TRUE)
sigfill(c(0.00123, 0.000987), 6, TRUE)
sigfill(c(0.00123, 0.000987), 3, TRUE)
two.by.two.paired <- function(frame, col.1, col.2) {
col.1.row.1 <- 0
col.1.row.2 <- 0
col.2.row.1 <- 0
col.2.row.2 <- 0
for (a in 1:nrow(frame)) {
if (frame[a, col.1] != 0 & frame[a, col.2] != 0) {
col.1.row.1 <- col.1.row.1 + 1
}
else if (frame[a, col.1] != 0 & frame[a, col.2] == 0) {
col.1.row.2 <- col.1.row.2 + 1
}
else if (frame[a, col.1] == 0 & frame[a, col.2] != 0) {
col.2.row.1 <- col.2.row.1 + 1
}
else if (frame[a, col.1] == 0 & frame[a, col.2] == 0) {
col.2.row.2 <- col.2.row.2 + 1
}
}
two.by.two <- data.frame(col.1 = c(col.1.row.1, col.1.row.2),
col.2 = c(col.2.row.1, col.2.row.2))
colnames(two.by.two) <- c(paste0(col.1, ".yes"), paste0(col.1,
".no"))
rownames(two.by.two) <- c(paste0(col.2, ".yes"), paste0(col.2,
".no"))
return(two.by.two)
}
frame <- data.frame("a"=c(3, 0.12, 0, 0, 0.001), "b"=c(0, 1, 0, 6, 9))
two.by.two.paired(frame, "a", "b")
class(round.to(0.00987, 0.001))
document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
rm(list = c("count.decimals", "count.n", "locate.element", "remove.na", "rename.column", "replace.na",
"replace.nan", "replace.specific", "row.bind", "sigfill", "two.by.two.paired", "uln", "uuln",
"which.col.name"))
devtools::document()
check()
devtools::check()
frame <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
frame_2 <- data.frame(frame, "d"=rowSums(frame))
merge.by.overlap(list(frame, frame_2))
devtools::check()
devtools::check()
object <- data.frame("a"=rep(1, 9), "b"=c(rep(1, 3), rep(2, 3), rep(3, 3)), "c"=1:9)
is(object, "data.frame")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
# once all functions are accounted for and properly documented
devtools::document()
devtools::check()
# once all functions are accounted for and properly documented
roxygen2::roxygenize()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
# once all functions are accounted for and properly documented
devtools::document()
devtools::check()
devtools::check()
usethis:use_readme_rmd()
usethis::use_readme_rmd()
build_readme()
usethis::build_readme()
rmarkdown::build_readme()
devtools::build_readme()
devtools::build_readme()
devtools::build_readme()
sigfill(c(0.00005, 0.0034), 3, TRUE)
sigfill(c(0.00005, 0.0034), 2, TRUE)
sigfill(c(0.005, 0.0034), 2, TRUE)
sigfill(c(0.05, 0.0034), 2, TRUE)
sigfill(c(0.045, 0.0034), 2, TRUE)
sigfill(c(0.049, 0.0034), 2, TRUE)
sigfill(c(0.047, 0.0034), 2, TRUE)
sigfill(c(0.043, 0.0034), 2, TRUE)
devtools::build_readme()
devtools::build_readme()
devtools::build_readme()
.Last.error.trace
devtools::build_readme()
